#!/usr/bin/env python3
"""
Phase 4 Verification: Enhanced Haystack Integration Test

Tests the complete pipeline: CourtListener ‚Üí FLP Enhancement ‚Üí PostgreSQL ‚Üí Haystack
"""
import asyncio
import sys
import os
import time
from datetime import datetime

# Add enhanced module to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'enhanced'))

from enhanced.enhanced_unified_processor import EnhancedUnifiedDocumentProcessor

class Phase4HaystackIntegration:
    """Test Phase 4: Enhanced Haystack integration with bulk ingestion"""
    
    def __init__(self):
        self.processor = None
        self.test_results = {
            'processor_initialization': False,
            'haystack_initialization': False,
            'bulk_service_health': False,
            'gilstrap_processing': False,
            'haystack_ingestion': False,
            'end_to_end_pipeline': False,
            'performance_validation': False
        }
        self.performance_metrics = {
            'processing_time': 0,
            'ingestion_time': 0,
            'total_documents': 0,
            'throughput': 0
        }
    
    def print_header(self, title: str):
        """Print formatted header"""
        print("\n" + "="*80)
        print(f" {title}")
        print("="*80)
    
    async def test_processor_initialization(self) -> bool:
        """Test 1: Enhanced processor with Haystack integration"""
        self.print_header("TEST 1: ENHANCED PROCESSOR INITIALIZATION")
        
        try:
            print("üîß Initializing Enhanced Processor with Haystack...")
            start_time = time.time()
            
            self.processor = EnhancedUnifiedDocumentProcessor()
            init_time = time.time() - start_time
            
            print(f"   ‚úÖ Processor initialized in {init_time:.2f}s")
            
            # Verify enhanced components
            components = {
                'CourtListener Service': self.processor.cl_service,
                'FLP Processor': self.processor.flp_processor,
                'Haystack Manager': self.processor.haystack_manager,
                'Document Validator': self.processor.document_validator,
                'Monitor': self.processor.monitor
            }
            
            print("   üìã Enhanced component verification:")
            all_critical_ok = True
            for name, component in components.items():
                status = "‚úÖ" if component else "‚ùå"
                print(f"      ‚Ä¢ {name}: {status}")
                if not component and name in ['CourtListener Service', 'Document Validator']:
                    all_critical_ok = False
            
            # Check Haystack availability specifically
            haystack_available = self.processor.haystack_manager is not None
            print(f"      ‚Ä¢ Haystack Integration: {'‚úÖ Available' if haystack_available else '‚ö†Ô∏è  Not available'}")
            
            self.test_results['processor_initialization'] = all_critical_ok
            return all_critical_ok
            
        except Exception as e:
            print(f"   ‚ùå Initialization failed: {str(e)}")
            self.test_results['processor_initialization'] = False
            return False
    
    async def test_haystack_initialization(self) -> bool:
        """Test 2: Haystack services initialization"""
        self.print_header("TEST 2: HAYSTACK SERVICES INITIALIZATION")
        
        try:
            print("üöÄ Testing Haystack integration services...")
            
            if not self.processor.haystack_manager:
                print("   ‚ö†Ô∏è  Haystack manager not available - using mock testing")
                self.test_results['haystack_initialization'] = False
                return False
            
            # Initialize Haystack manager
            await self.processor.haystack_manager.initialize()
            print("   ‚úÖ Haystack manager initialized")
            
            # Test health status
            health = await self.processor.haystack_manager.get_integration_health()
            print("   üìä Haystack health status:")
            
            if 'integration_manager' in health:
                manager_health = health['integration_manager']
                print(f"      ‚Ä¢ Integration Manager: {manager_health['status']}")
                print(f"      ‚Ä¢ Active Jobs: {manager_health['active_jobs']}")
            
            if 'bulk_service' in health:
                bulk_health = health['bulk_service']
                print(f"      ‚Ä¢ Bulk Service: {bulk_health['status']}")
                
                if 'services' in bulk_health:
                    print("      ‚Ä¢ Service connections:")
                    for service, info in bulk_health['services'].items():
                        status = "‚úÖ" if info.get('connected', False) else "‚ùå"
                        print(f"         - {service}: {status}")
            
            self.test_results['haystack_initialization'] = True
            return True
            
        except Exception as e:
            print(f"   ‚ùå Haystack initialization failed: {str(e)}")
            self.test_results['haystack_initialization'] = False
            return False
    
    async def test_bulk_service_health(self) -> bool:
        """Test 3: Bulk service health and capabilities"""
        self.print_header("TEST 3: BULK SERVICE HEALTH CHECK")
        
        try:
            print("‚ö° Testing bulk service capabilities...")
            
            if not self.processor.haystack_manager:
                print("   ‚ö†Ô∏è  Haystack manager not available")
                self.test_results['bulk_service_health'] = False
                return False
            
            # Get performance metrics
            metrics = await self.processor.haystack_manager.get_performance_metrics()
            print("   üìä Performance metrics:")
            
            if 'bulk_service' in metrics:
                bulk_metrics = metrics['bulk_service']
                
                if 'system' in bulk_metrics:
                    system = bulk_metrics['system']
                    print(f"      ‚Ä¢ Memory: {system['memory_rss_mb']:.1f} MB")
                    print(f"      ‚Ä¢ CPU: {system['cpu_percent']:.1f}%")
                
                if 'connections' in bulk_metrics:
                    connections = bulk_metrics['connections']
                    print("      ‚Ä¢ Connection pools:")
                    for service, info in connections.items():
                        if isinstance(info, dict) and 'size' in info:
                            print(f"         - {service}: {info['idle_connections']}/{info['size']} idle")
            
            if 'job_management' in metrics:
                job_stats = metrics['job_management']
                print(f"      ‚Ä¢ Job management ready: ‚úÖ")
                print(f"         - Total jobs: {job_stats['total_jobs']}")
                print(f"         - Running: {job_stats['running_jobs']}")
            
            self.test_results['bulk_service_health'] = True
            return True
            
        except Exception as e:
            print(f"   ‚ùå Bulk service health check failed: {str(e)}")
            self.test_results['bulk_service_health'] = False
            return False
    
    async def test_gilstrap_processing(self) -> bool:
        """Test 4: Gilstrap document processing with enhanced pipeline"""
        self.print_header("TEST 4: JUDGE GILSTRAP PROCESSING")
        
        try:
            print("üìÑ Testing enhanced Gilstrap document processing...")
            
            start_time = time.time()
            batch_result = await self.processor.process_gilstrap_documents_batch(
                max_documents=2  # Small test batch
            )
            processing_time = time.time() - start_time
            
            print(f"   ‚úÖ Gilstrap processing completed in {processing_time:.2f}s")
            print(f"   üìä Processing results:")
            print(f"      ‚Ä¢ Documents fetched: {batch_result.get('total_fetched', 0)}")
            print(f"      ‚Ä¢ New documents: {batch_result.get('new_documents', 0)}")
            print(f"      ‚Ä¢ Duplicates: {batch_result.get('duplicates', 0)}")
            print(f"      ‚Ä¢ Errors: {batch_result.get('errors', 0)}")
            
            # Update performance metrics
            self.performance_metrics['processing_time'] = processing_time
            self.performance_metrics['total_documents'] = batch_result.get('new_documents', 0)
            
            self.test_results['gilstrap_processing'] = True
            return True
            
        except Exception as e:
            print(f"   ‚ùå Gilstrap processing failed: {str(e)}")
            self.test_results['gilstrap_processing'] = False
            return False
    
    async def test_haystack_ingestion(self) -> bool:
        """Test 5: Haystack bulk ingestion"""
        self.print_header("TEST 5: HAYSTACK BULK INGESTION")
        
        try:
            print("üöÄ Testing Haystack bulk ingestion...")
            
            if not self.processor.haystack_manager:
                print("   ‚ö†Ô∏è  Haystack manager not available - cannot test ingestion")
                self.test_results['haystack_ingestion'] = False
                return False
            
            # Test ingestion of recent Gilstrap documents
            start_time = time.time()
            job_id = await self.processor.ingest_gilstrap_to_haystack(max_documents=5)
            
            print(f"   üîÑ Haystack ingestion job started: {job_id}")
            
            # Monitor job for a short time (30 seconds max for test)
            monitor_start = time.time()
            final_status = None
            
            while time.time() - monitor_start < 30:
                try:
                    status = self.processor.haystack_manager.get_job_status(job_id)
                    
                    if status:
                        current_status = status['status']
                        
                        if current_status in ['completed', 'failed', 'cancelled']:
                            final_status = status
                            break
                        
                        print(f"      ‚Ä¢ Job status: {current_status}")
                    
                    await asyncio.sleep(3)
                    
                except Exception as e:
                    print(f"      ‚ö†Ô∏è  Monitoring error: {str(e)}")
                    break
            
            ingestion_time = time.time() - start_time
            self.performance_metrics['ingestion_time'] = ingestion_time
            
            if final_status:
                if final_status['status'] == 'completed':
                    stats = final_status.get('stats', {})
                    print(f"   ‚úÖ Haystack ingestion completed in {ingestion_time:.2f}s")
                    print(f"      ‚Ä¢ Total documents: {stats.get('total_documents', 0)}")
                    print(f"      ‚Ä¢ Successful: {stats.get('successful_documents', 0)}")
                    print(f"      ‚Ä¢ Failed: {stats.get('failed_documents', 0)}")
                    print(f"      ‚Ä¢ Success rate: {stats.get('success_rate', 0):.1f}%")
                    print(f"      ‚Ä¢ Throughput: {stats.get('throughput', 0):.2f} docs/sec")
                else:
                    print(f"   ‚ùå Haystack ingestion {final_status['status']}: {final_status.get('error', 'Unknown')}")
                    self.test_results['haystack_ingestion'] = False
                    return False
            else:
                print(f"   ‚ö†Ô∏è  Haystack ingestion job still running after 30s")
                print(f"      ‚Ä¢ Job ID: {job_id} (check status manually)")
            
            self.test_results['haystack_ingestion'] = True
            return True
            
        except Exception as e:
            print(f"   ‚ùå Haystack ingestion test failed: {str(e)}")
            self.test_results['haystack_ingestion'] = False
            return False
    
    async def test_end_to_end_pipeline(self) -> bool:
        """Test 6: Complete end-to-end pipeline"""
        self.print_header("TEST 6: END-TO-END PIPELINE")
        
        try:
            print("üîÑ Testing complete pipeline: CourtListener ‚Üí FLP ‚Üí PostgreSQL ‚Üí Haystack")
            
            if not self.processor.haystack_manager:
                print("   ‚ö†Ô∏è  Haystack manager not available - testing without Haystack")
                # Just test the processing pipeline
                result = await self.processor.process_gilstrap_documents_batch(max_documents=1)
                success = result.get('new_documents', 0) > 0 or result.get('total_fetched', 0) > 0
                self.test_results['end_to_end_pipeline'] = success
                return success
            
            # Test complete pipeline with Haystack
            start_time = time.time()
            result = await self.processor.process_and_ingest_to_haystack(
                court_id="txed",
                judge_name="Gilstrap",
                max_documents=1
            )
            total_time = time.time() - start_time
            
            print(f"   ‚úÖ End-to-end pipeline completed in {total_time:.2f}s")
            print(f"   üìä Pipeline results:")
            print(f"      ‚Ä¢ Processing: {result.get('new_documents', 0)} documents")
            
            if 'haystack_ingestion' in result:
                haystack_result = result['haystack_ingestion']
                print(f"      ‚Ä¢ Haystack ingestion: {'‚úÖ Success' if haystack_result['success'] else '‚ùå Failed'}")
                
                if haystack_result['success'] and 'stats' in haystack_result:
                    stats = haystack_result['stats']
                    print(f"         - Documents ingested: {stats.get('successful_documents', 0)}")
                elif not haystack_result['success']:
                    print(f"         - Error: {haystack_result.get('error', 'Unknown')}")
            
            self.test_results['end_to_end_pipeline'] = True
            return True
            
        except Exception as e:
            print(f"   ‚ùå End-to-end pipeline test failed: {str(e)}")
            self.test_results['end_to_end_pipeline'] = False
            return False
    
    async def test_performance_validation(self) -> bool:
        """Test 7: Performance validation"""
        self.print_header("TEST 7: PERFORMANCE VALIDATION")
        
        try:
            print("‚ö° Validating system performance...")
            
            # Calculate overall throughput
            total_time = self.performance_metrics['processing_time'] + self.performance_metrics['ingestion_time']
            total_docs = self.performance_metrics['total_documents']
            
            if total_time > 0 and total_docs > 0:
                throughput = total_docs / total_time
                self.performance_metrics['throughput'] = throughput
                
                print(f"   üìä Performance analysis:")
                print(f"      ‚Ä¢ Total processing time: {self.performance_metrics['processing_time']:.2f}s")
                print(f"      ‚Ä¢ Total ingestion time: {self.performance_metrics['ingestion_time']:.2f}s")
                print(f"      ‚Ä¢ Total documents: {total_docs}")
                print(f"      ‚Ä¢ Overall throughput: {throughput:.2f} docs/sec")
                
                # Validate performance benchmarks
                performance_ok = True
                if throughput < 0.1:  # Less than 0.1 docs/sec is concerning
                    print(f"      ‚ö†Ô∏è  Low throughput detected")
                    performance_ok = False
                else:
                    print(f"      ‚úÖ Performance within acceptable range")
            else:
                print(f"   ‚ö†Ô∏è  Insufficient data for performance analysis")
                performance_ok = False
            
            # System health check
            health = self.processor.get_health_status()
            print(f"   üè• System health:")
            print(f"      ‚Ä¢ Status: {health.get('status', 'Unknown')}")
            print(f"      ‚Ä¢ Uptime: {health.get('uptime_seconds', 0):.1f}s")
            
            if 'components' in health:
                components = health['components']
                print(f"      ‚Ä¢ Environment: {components.get('environment', 'Unknown')}")
            
            self.test_results['performance_validation'] = performance_ok
            return performance_ok
            
        except Exception as e:
            print(f"   ‚ùå Performance validation failed: {str(e)}")
            self.test_results['performance_validation'] = False
            return False
    
    def print_final_report(self):
        """Print comprehensive final report"""
        self.print_header("PHASE 4 HAYSTACK INTEGRATION REPORT")
        
        print("üéØ **TEST RESULTS:**")
        for test_name, result in self.test_results.items():
            status = "‚úÖ PASS" if result else "‚ùå FAIL"
            print(f"   ‚Ä¢ {test_name.replace('_', ' ').title()}: {status}")
        
        passed_tests = sum(1 for result in self.test_results.values() if result)
        total_tests = len(self.test_results)
        
        print(f"\nüìä **OVERALL RESULTS:**")
        print(f"   ‚Ä¢ Tests passed: {passed_tests}/{total_tests}")
        print(f"   ‚Ä¢ Success rate: {(passed_tests/total_tests)*100:.1f}%")
        
        if self.performance_metrics['total_documents'] > 0:
            print(f"\n‚ö° **PERFORMANCE SUMMARY:**")
            print(f"   ‚Ä¢ Documents processed: {self.performance_metrics['total_documents']}")
            print(f"   ‚Ä¢ Processing time: {self.performance_metrics['processing_time']:.2f}s")
            print(f"   ‚Ä¢ Ingestion time: {self.performance_metrics['ingestion_time']:.2f}s")
            print(f"   ‚Ä¢ Overall throughput: {self.performance_metrics['throughput']:.2f} docs/sec")
        
        print(f"\nüöÄ **PHASE 4 INTEGRATION STATUS:**")
        if passed_tests >= 5:  # Most critical tests passed
            print(f"   ‚úÖ PHASE 4 HAYSTACK INTEGRATION SUCCESSFUL")
            print(f"   üìã Complete pipeline operational: CourtListener ‚Üí FLP ‚Üí PostgreSQL ‚Üí Haystack")
            print(f"   üîç Enhanced search capabilities now available")
        else:
            print(f"   ‚ùå PHASE 4 INTEGRATION NEEDS IMPROVEMENT")
            print(f"   üîß Address failed tests before production deployment")
        
        return passed_tests >= 5

async def run_phase4_test():
    """Run Phase 4 Haystack integration test"""
    
    integration_test = Phase4HaystackIntegration()
    
    integration_test.print_header("PHASE 4 HAYSTACK INTEGRATION TEST")
    print("üéØ Testing complete enhanced pipeline with Haystack bulk ingestion")
    print(f"üìÖ Test timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    # Run all tests
    tests = [
        integration_test.test_processor_initialization,
        integration_test.test_haystack_initialization,
        integration_test.test_bulk_service_health,
        integration_test.test_gilstrap_processing,
        integration_test.test_haystack_ingestion,
        integration_test.test_end_to_end_pipeline,
        integration_test.test_performance_validation
    ]
    
    for test in tests:
        await test()
    
    # Generate final report
    success = integration_test.print_final_report()
    
    return success

if __name__ == "__main__":
    try:
        print("üöÄ Starting Phase 4 Haystack integration test...")
        success = asyncio.run(run_phase4_test())
        
        if success:
            print("\nüéâ PHASE 4 INTEGRATION COMPLETE!")
            print("‚úÖ Enhanced Judge Gilstrap processing with Haystack search ready for production")
        else:
            print("\n‚ùå Phase 4 integration test failed")
            print("üîß Review failed tests before production deployment")
            
        sys.exit(0 if success else 1)
        
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è  Test interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n\nüí• Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)