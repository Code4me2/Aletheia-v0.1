#!/usr/bin/env python3
"""
Environment Configuration Generator for Aletheia
Generates .env files from centralized port configuration
"""

import json
import os
import sys
from pathlib import Path

def load_port_config():
    """Load the centralized port configuration"""
    # Since we can't use yaml, define the config directly
    return {
        'environments': {
            'development': {
                'core_services': {'web': 8080, 'api_gateway': 8081, 'reverse_proxy': 8082},
                'application_services': {'n8n': 8100, 'lawyer_chat': 8101, 'ai_portal': 8102},
                'data_services': {'postgresql': 8200, 'redis': 8201, 'elasticsearch': 8202},
                'ai_services': {'haystack': 8500, 'bitnet': 8501, 'ollama_proxy': 8502},
                'monitoring': {'prometheus': 8300, 'grafana': 8301, 'loki': 8302, 'node_exporter': 8303}
            },
            'staging': {
                'core_services': {'web': 9080, 'api_gateway': 9081, 'reverse_proxy': 9082},
                'application_services': {'n8n': 9100, 'lawyer_chat': 9101, 'ai_portal': 9102},
                'data_services': {'postgresql': 9200, 'redis': 9201, 'elasticsearch': 9202},
                'ai_services': {'haystack': 9500, 'bitnet': 9501, 'ollama_proxy': 9502},
                'monitoring': {'prometheus': 9300, 'grafana': 9301, 'loki': 9302, 'node_exporter': 9303}
            },
            'production': {
                'core_services': {'web': 80, 'web_ssl': 443, 'api_gateway': 8080},
                'application_services': {'n8n': 5678, 'lawyer_chat': 3000, 'ai_portal': 3001},
                'data_services': {'postgresql': 5432, 'redis': 6379, 'elasticsearch': 9200},
                'ai_services': {'haystack': 8000, 'bitnet': 8001},
                'monitoring': {'prometheus': 9090, 'grafana': 3000, 'loki': 3100, 'node_exporter': 9100}
            }
        },
        'reserved_ranges': {
            'system': [1, 1023],
            'common_services': [3000, 3010, 5432, 5678, 6379, 8080, 9090, 9200],
            'avoid': [22, 25, 53, 80, 110, 143, 443, 993, 995]
        }
    }

def generate_env_file(environment, output_path=None):
    """Generate .env file for specified environment"""
    config = load_port_config()
    
    if environment not in config['environments']:
        raise ValueError(f"Environment '{environment}' not found in configuration")
    
    env_config = config['environments'][environment]
    
    # Generate environment variables
    env_vars = {
        # Project configuration
        'COMPOSE_PROJECT_NAME': f'aletheia_{environment}',
        'ENVIRONMENT': environment,
        
        # Core services
        'WEB_PORT': env_config['core_services']['web'],
        'API_GATEWAY_PORT': env_config['core_services'].get('api_gateway', 8081),
        'REVERSE_PROXY_PORT': env_config['core_services'].get('reverse_proxy', 8082),
        
        # Application services
        'N8N_PORT': env_config['application_services']['n8n'],
        'LAWYER_CHAT_PORT': env_config['application_services']['lawyer_chat'],
        'AI_PORTAL_PORT': env_config['application_services']['ai_portal'],
        
        # Data services
        'POSTGRES_PORT': env_config['data_services']['postgresql'],
        'REDIS_PORT': env_config['data_services']['redis'],
        'ELASTICSEARCH_PORT': env_config['data_services']['elasticsearch'],
        
        # AI services
        'HAYSTACK_PORT': env_config['ai_services']['haystack'],
        'BITNET_PORT': env_config['ai_services']['bitnet'],
        'OLLAMA_PROXY_PORT': env_config['ai_services'].get('ollama_proxy', 8502),
        
        # Monitoring
        'PROMETHEUS_PORT': env_config['monitoring']['prometheus'],
        'GRAFANA_PORT': env_config['monitoring']['grafana'],
        'LOKI_PORT': env_config['monitoring']['loki'],
        'NODE_EXPORTER_PORT': env_config['monitoring']['node_exporter'],
    }
    
    # Add SSL ports for production
    if environment == 'production':
        env_vars['WEB_SSL_PORT'] = env_config['core_services'].get('web_ssl', 443)
    
    # Create output path if not specified
    if output_path is None:
        output_path = Path(__file__).parent.parent / f".env.{environment}"
    
    # Write .env file
    with open(output_path, 'w') as f:
        f.write(f"# Generated environment configuration for {environment.upper()}\n")
        f.write(f"# Generated by generate-env.py\n")
        f.write(f"# DO NOT EDIT MANUALLY - Edit config/ports.yml instead\n\n")
        
        # Group variables by category
        categories = [
            ('Project Configuration', ['COMPOSE_PROJECT_NAME', 'ENVIRONMENT']),
            ('Core Services', [k for k in env_vars.keys() if any(x in k for x in ['WEB_', 'API_', 'REVERSE_'])]),
            ('Application Services', [k for k in env_vars.keys() if any(x in k for x in ['N8N_', 'LAWYER_', 'AI_PORTAL'])]),
            ('Data Services', [k for k in env_vars.keys() if any(x in k for x in ['POSTGRES_', 'REDIS_', 'ELASTICSEARCH_'])]),
            ('AI Services', [k for k in env_vars.keys() if any(x in k for x in ['HAYSTACK_', 'BITNET_', 'OLLAMA_'])]),
            ('Monitoring', [k for k in env_vars.keys() if any(x in k for x in ['PROMETHEUS_', 'GRAFANA_', 'LOKI_', 'NODE_EXPORTER_'])]),
        ]
        
        for category_name, keys in categories:
            if any(k in env_vars for k in keys):
                f.write(f"# {category_name}\n")
                for key in keys:
                    if key in env_vars:
                        f.write(f"{key}={env_vars[key]}\n")
                f.write("\n")
    
    print(f"Generated {output_path} for {environment} environment")
    return output_path

def check_port_conflicts(environment):
    """Check for port conflicts in the specified environment"""
    config = load_port_config()
    
    if environment not in config['environments']:
        raise ValueError(f"Environment '{environment}' not found")
    
    env_config = config['environments'][environment]
    used_ports = []
    conflicts = []
    
    # Collect all ports
    for service_group in env_config.values():
        if isinstance(service_group, dict):
            for service, port in service_group.items():
                if port in used_ports:
                    conflicts.append((port, service))
                used_ports.append(port)
    
    # Check against reserved ranges
    reserved = config.get('reserved_ranges', {})
    for port in used_ports:
        for range_name, range_ports in reserved.items():
            if isinstance(range_ports, list):
                if len(range_ports) == 2 and range_ports[0] <= port <= range_ports[1]:
                    conflicts.append((port, f"conflicts with {range_name} range"))
                elif port in range_ports:
                    conflicts.append((port, f"conflicts with {range_name}"))
    
    return conflicts

def main():
    """Main CLI interface"""
    if len(sys.argv) != 2:
        print("Usage: python generate-env.py <environment>")
        print("Available environments: development, staging, production")
        sys.exit(1)
    
    environment = sys.argv[1].lower()
    
    try:
        # Check for conflicts first
        conflicts = check_port_conflicts(environment)
        if conflicts:
            print(f"Warning: Port conflicts detected in {environment}:")
            for port, issue in conflicts:
                print(f"  Port {port}: {issue}")
            print()
        
        # Generate the environment file
        output_path = generate_env_file(environment)
        print(f"Environment file generated successfully: {output_path}")
        
        # Show summary
        config = load_port_config()
        env_config = config['environments'][environment]
        print(f"\nPort summary for {environment}:")
        for group_name, group_ports in env_config.items():
            if isinstance(group_ports, dict):
                print(f"  {group_name.replace('_', ' ').title()}:")
                for service, port in group_ports.items():
                    print(f"    {service}: {port}")
        
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()